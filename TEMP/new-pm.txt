CodeIgniter PHP Framework
CodeIgniter is an open source rapid development web application framework, for use in building dynamic web sites with [PHP].

CodeIgniter is loosely based on the popular [Model-View-Controller] [development pattern]. While controller classes are a necessary part of development under CodeIgniter, models and views are optional.

CodeIgniter is most often noted for its speed when compared to other [PHP frameworks]. In a critical take on PHP frameworks in general, PHP creator [Rasmus Lerdorf] spoke at frOSCon in August 2008, noting that he liked CodeIgniter "<em>because it is faster, lighter and the least like a framework</em>"

The first public version of CodeIgniter was released by EllisLab on 28 February 2006, and the latest stable version 3.0.0 was released 30 March 30, 2015. On 9 July 2013, EllisLab announced that it was seeking a new owner for CodeIgniter, citing a lack of resources to give the framework the attention they felt it deserved. On 6 October 2014, EllisLab announced that CodeIgniter would continue development under the stewardship of the British Columbia Institute of Technology.
===

Laravel PHP Framework
Laravel is a free, open-source [PHP] web application framework, created by Taylor Otwell and intended for the development of web applications following the [model–view–controller] (MVC) architectural pattern. Prominent Laravel features include its expressive syntax, a modular packaging system with a dedicated dependency manager, different ways for accessing relational databases, and various utilities that aid in application deployment and maintenance.

According to a March 2015 developers survey on PHP frameworks popularity, Laravel was listed as the most popular PHP framework of 2015, followed by [Symfony2], Nette, [CodeIgniter], [Yii] and others.

Laravel was created by Taylor Otwell as a more feature-rich alternative to the CodeIgniter framework, which did not provide various advanced features such as support for user authentication and authorization. Laravel's first beta release was made available on 9 June 2011, followed by the Laravel 1 release later in the same month. Laravel 1 includes built-in support for authentication, localisation, models, views, sessions, routing and other mechanisms, but lacks support for controllers that prevents it from being a true MVC framework.

Laravel 2 was released in September 2011, bringing various improvements from the author and community. Major new features include the support for controllers, which made Laravel 2 a fully MVC-compliant framework, built-in support for the [inversion of control] (IoC) principle, and the so-called "Blade" templating system. As a downside, support for third-party packages was removed in Laravel 2.

Laravel 3 was released in February 2012 with a set of new features including the [command-line interface] (CLI) named "Artisan", built-in support for more database management systems, database migrations as a form of version control for database layouts, support for handling events, and a packaging system called "Bundles". A significant increase of the Laravel's userbase and popularity lined up with the release of Laravel 3.

Laravel 4, codenamed "Illuminate", was released in May 2013. It was made as a complete rewrite of the Laravel framework, migrating its layout into a set of separate packages distributed through [Composer], which serves as an application-level package manager. Such a layout allowed much better extendibility of Laravel 4, paired with its official regular release schedule spanning six months between minor point releases. Other new features in the Laravel 4 release include database seeding for the initial population of databases, support for message queues, built-in support for sending different types of email, and support for delayed deletion of database records called "soft deletion".

Laravel 5 was released in February 2015 as a result of significant changes that ended up in renumbering the then future Laravel 4.3 release. Beside bringing various new features and improvements to already existing ones, Laravel 5 also introduced a new internal directory tree structure for developed applications. New features in the Laravel 5 release include support for scheduling periodically executed tasks through a package called "Scheduler", an abstraction layer called "Flysystem" that allows remote storage to be used in the same way as local file systems, improved handling of package assets through "Elixir", and simplified externally handled authentication through the optional "Socialite" package.

Laravel 5.1, released in June 2015, is the first release of Laravel to receive long-term support (LTS), with planned availability of bug fixes for two years and security patches for three years. LTS releases of Laravel are planned to be released every two years.
===

Design Patterns

<p>A <strong>design pattern</strong> is a general reusable solution to a commonly occurring problem within a given context in software design.</p>
<p>A design pattern is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations. Patterns are formalised best practices that the programmer can use to solve common problems when designing an application or system. Object-oriented design patterns typically show relationships and interactions between classes or objects, without specifying the final application classes or objects that are involved. Patterns that imply object-orientation or, more generally, mutable state, are not as applicable in functional programming languages.</p>
<p>Patterns originated as an architectural concept by <strong>Christopher Alexander</strong> (1977 / 79). In 1987, <strong>Kent Beck</strong> and <strong>Ward Cunningham</strong> began experimenting with the idea of applying patterns to programming - specifically pattern languages - and presented their results at the OOPSLA conference that year. In the following years, Beck, Cunningham and others followed up on this work.</p>
<p>Design patterns gained popularity in computer science after the book [Design Patterns: Elements of Reusable Object-Oriented Software] was published in 1994 by the so-called "[Gang of Four]", which is frequently abbreviated as "GoF". That same year, the first Pattern Languages of Programming Conference was held and the following year, the <strong>Portland Pattern Repository</strong> was set up for documentation of design patterns.</p>

<h2>Patterns By Type</h2>

<h3>[Creational patterens]<h3>
<p>Creational patterns are ones that create objects for you, rather than having you instantiate objects directly. This gives your program more flexibility in deciding which objects need to be created for a given case.</p>

<ul>
	<li>[Abstract factory] pattern groups object factories that have a common theme.</li>
	<li>[Builder] pattern constructs complex objects by separating construction and representation.</li>
	<li>[Factory method] pattern creates objects without specifying the exact class to create.</li>
	<li>[Prototype] pattern creates objects by cloning an existing object.</li>
	<li>[Singleton] pattern restricts object creation for a class to only one instance.</li>
	<li>[Lazy initialisation] tactic of delaying the creation of an object, the calculation of a value, or some other expensive process until the first time it is needed. This pattern appears in the GoF catalog as "virtual proxy", an implementation strategy for the Proxy pattern.</li>
	<li>[Multiton] ensure a class has only named instances, and provide a global point of access to them.</li>
	<li>[Object pool] avoid expensive acquisition and release of resources by recycling objects that are no longer in use. Can be considered a generalisation of connection pool and thread pool patterns.</li>
	<li>[Resource acquisition is initialisation] ensure that resources are properly released by tying them to the lifespan of suitable objects.</li>
</ul>

<h3>[Structural patterens]</h3>
<p>These concern class and object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality.</p>

<ul>
	<li>[Adapter] allows classes with incompatible interfaces to work together by wrapping its own interface around that of an already existing class.</li>
	<li>[Bridge] decouples an abstraction from its implementation so that the two can vary independently.</li>
	<li>[Composite] composes zero-or-more similar objects so that they can be manipulated as one object.</li>
	<li>[Decorator] dynamically adds / overrides behaviour in an existing method of an object.</li>
	<li>[Facade] provides a simplified interface to a large body of code.</li>
	<li>[Flyweight] reduces the cost of creating and manipulating a large number of similar objects.</li>
	<li>[Proxy] provides a placeholder for another object to control access, reduce cost, and reduce complexity.</li>
	<li>[Front Controller] pattern relates to the design of Web applications. It provides a centralised entry point for handling requests.</li>
	<li>[Module] group several related elements, such as classes, singletons, methods, globally used, into a single conceptual entity.</li>
</ul>

<h3>[Behavioural patterens]</h3>
<p>Most of these design patterns are specifically concerned with communication between objects.</p>

<ul>
	<li>[Chain of responsibility] delegates commands to a chain of processing objects.</li>
	<li>[Command] creates objects which encapsulate actions and parameters.</li>
	<li>[Interpreter] implements a specialised language.</li>
	<li>[Iterator] accesses the elements of an object sequentially without exposing its underlying representation.</li>
	<li>[Mediator] allows loose coupling between classes by being the only class that has detailed knowledge of their methods.</li>
	<li>[Memento] provides the ability to restore an object to its previous state (undo).</li>
	<li>[Observer] is a publish/subscribe pattern which allows a number of observer objects to see an event.</li>
	<li>[State] allows an object to alter its behavior when its internal state changes.</li>
	<li>[Strategy] allows one of a family of algorithms to be selected on-the-fly at runtime.</li>
	<li>[Template] method defines the skeleton of an algorithm as an abstract class, allowing its subclasses to provide concrete behavior.</li>
	<li>[Visitor] separates an algorithm from an object structure by moving the hierarchy of methods into one object.</li>
	<li>[Null object] avoid null references by providing a default object.</li>
	<li>[Servant] define common functionality for a group of classes.</li>
	<li>[Specification] recombinable business logic in a Boolean fashion.</li>
</ul>

<h3>[Concurrency patterens]</h3>
<ul>
	<li>[Active Object] decouples method execution from method invocation that reside in their own thread of control. The goal is to introduce concurrency, by using asynchronous method invocation and a scheduler for handling requests.</li>
	<li>[Balking] only execute an action on an object when the object is in a particular state.</li>
	<li>[Double-checked locking] reduce the overhead of acquiring a lock by first testing the locking criterion (the 'lock hint') in an unsafe manner; only if that succeeds does the actual locking logic proceed.</li>
	<li>[Event-based asynchronous] addresses problems with the asynchronous pattern that occur in multithreaded programs.</li>
	<li>[Guarded suspension] manages operations that require both a lock to be acquired and a precondition to be satisfied before the operation can be executed.</li>
	<li>[Join] provides a way to write concurrent, parallel and distributed programs by message passing. Compared to the use of threads and locks, this is a high level programming model.</li>
	<li>[Lock] one thread puts a "lock" on a resource, preventing other threads from accessing or modifying it.</li>
	<li>[Messaging design pattern (MDP)] allows the interchange of information (i.e. messages) between components and applications.</li>
	<li>[Monitor object] an object whose methods are subject to mutual exclusion, thus preventing multiple objects from erroneously trying to use it at the same time.</li>
	<li>[Reactor] provides an asynchronous interface to resources that must be handled synchronously.</li>
	<li>[Read-write lock] allows concurrent read access to an object, but requires exclusive access for write operations.</li>
	<li>[Scheduler] explicitly control when threads may execute single-threaded code.</li>
	<li>[Thread pool] a number of threads are created to perform a number of tasks, which are usually organized in a queue. Typically, there are many more tasks than threads.
	<li>[Thread-specific storage] static or "global" memory local to a thread.
<ul>
===
