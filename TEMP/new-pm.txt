
Backbone.js 
Backbone.js is a [JavaScript] library with a [RESTful] [JSON] interface and is based on the [model–view–presenter] (MVP) application design paradigm. Backbone is known for being lightweight, as its only dependency is on one JavaScript library, [Underscore.js]. It is designed for developing [single-page web applications], and for keeping various parts of web applications (e.g. multiple clients and the server) synchronised. Backbone was created by Jeremy Ashkenas, who is also known for [CoffeeScript].
===

Ember.js
Ember.js is an open-source [JavaScript] web application framework. It is based on the [model-view-controller] (MVC) software architectural pattern. It allows developers to create scalable [single-page applications] by incorporating common idioms and best practices into the framework. It provides a rich object model, declarative two-way data binding, computed properties, automatically-updating templates powered by HTMLBars, and a router for managing application state.
===

Knockout
Knockout is a standalone [JavaScript] implementation of the [Model-View-ViewModel] pattern with templates. The underlying principles are therefore:

- a clear separation between domain data, view components and data to be displayed
- the presence of a clearly defined layer of specialized code to manage the relationships between the view components

The latter leverages the native event management features of the JavaScript language.

These features streamline and simplify the specification of complex relationships between view components, which in turn make the display more responsive and the user experience richer.
===

Modernizr
Modernizr is a [JavaScript] library which is designed to detect [HTML5] and [CSS3] features in various browsers. Since the specifications for both HTML5 and CSS3 are only partially implemented or nonexistent in many browsers, it can be difficult to determine which techniques are available for use in rendering a page, and when it is necessary to avoid using a feature or to load a workaround such as a shim to emulate the feature. Modernizr aims to provide this feature detection in a complete and standardised manner.

===

Shim
In computer programming, a shim is a small library that transparently intercepts [API] calls and changes the arguments passed, handles the operation itself, or redirects the operation elsewhere. Shims typically come about when the behaviour of an API changes, thereby causing compatibility issues for older applications which still rely on the older functionality. In such cases, the older API can still be supported by a thin compatibility layer on top of the newer code. [Web polyfills] are a related concept. Shims can also be used for running programs on different software platforms than they were developed for.
===

HTML5Shiv
HTML5Shiv is a [JavaScript] workaround, created by Sjoerd Visscher, to enable styling of [HTML5] elements in versions of [Internet Explorer] prior to version 9, which do not allow unknown elements to be styled without [JavaScript].

Prior to version 9 of Internet Explorer there was little to no support for HTML5 elements and other HTML5 features.

Internet Explorer commands a large percentage of the usage share of web browsers. Within the Internet Explorer percentage, most of its current usage as of February 2013 comes from version 9, with version 8 holding the second-highest and version 7 the third-highest value. With its high usage percentage, it is important to ensure that web pages function correctly in Internet Explorer. HTML5Shiv allows versions of Internet Explorer prior to version 9 to recognise the HTML5 tags and allows them to be styled using CSS.
===

Web Polyfill
In web development, a polyfill (or polyfiller) is downloadable code which provides facilities that are not built into a [web browser]. It implements technology that a developer expects the browser to provide natively, providing a more uniform API landscape. For example, many features of HTML5 are not supported by versions of [Internet Explorer] older than version 8 or 9, but can be used by web pages if those pages install a polyfill. Web [shims] and HTML5 Shivs are related concepts.

The term originated with Remy Sharp who required a word that meant “replicate an API using JavaScript (or [Flash] or whatever) if the browser doesn’t have it natively” while co-writing the book 'Introducing HTML5' in 2009. Shim, to him, meant a piece of code that you could add that would fix some functionality, but it would most often have its own API, thus did not fulfil Sharp's terminology requirements. The terms progressive enhancement and graceful degradation similarly did not meet his needs since they didn't specifically require, nor were they specific to, JavaScript.

Sharp decided upon the term polyfill that can imply filling in missing browser functionality and using any number of techniques (poly can mean “many” in Greek). Polyfilla, a paste used to cover up cracks and holes in walls, was also a visualisation that Sharp found fitting for the term. He has received feedback stating that the “word should be changed”, but the term has now grown more popular amongst web developers. Sharp intentionally did not promote the term widely, only using it in specific cases and believes that it received a large amount of exposure after Paul Irish directly referenced the term in a presentation months after its inception and was helped become popular due to [Modernizr]'s “HTML5 shims & polyfill” page.

Examples

html5shiv
In IE versions prior to 9, unknown HTML elements like <section> and <nav> would be parsed as empty elements, breaking the page's nesting structure and making those elements impossible to style using CSS. One of the most widely used polyfills, html5shiv exploits another quirk of IE to work around this bug: calling document.createElement("tagname") for each of the new HTML5 elements, which causes IE to parse them correctly. It also includes basic default styling for those HTML5 elements.

-prefix-free
Though most polyfills target out-of-date browsers, some exist to simply push modern browsers forward a little bit more. Lea Verou's -prefix-free polyfill is such a polyfill, allowing current browsers to recognise the unprefixed versions of several CSS3 properties instead of requiring the developer to write out all the vendor prefixes. It reads the page's stylesheets and replaces any unprefixed properties with their prefixed counterparts recognised by the current browser.

Selectivizr
Keith Clark's Selectivizr is a popular polyfill that makes many CSS3 selectors work in IE 8 and below. It reads the page's stylesheets looking for a number of known CSS3 selectors, then uses a JavaScript selector library to query the document for elements matching those selectors, applying the styles directly to those elements. It supports several JavaScript selector libraries such as jQuery.

Flexie
Possibly one of the most anticipated features of CSS3, Flexible Box Layout (a.k.a. Flexbox) promises to be an extremely powerful tool for laying out interface elements. WebKit and Mozilla engines have supported a preliminary draft syntax for years. Flexie implements support for that same syntax in IE and Opera. However, the draft spec has undergone a drastic revision to a new (and much more powerful) syntax, which is not yet supported by Flexie. Flexie can still be used along with the old syntax, but the developer must make sure they include the new syntax for future browsers as well.

CSS3 PIE
PIE ("Progressive Internet Explorer") implements some of the most popular missing CSS3 box decoration properties in IE, including border-radius and box-shadow for IE 8 and below, and linear-gradient backgrounds for IE 9 and below. Invoked as a HTC behavior (a proprietary IE feature), it looks for the unsupported CSS3 properties on specific elements and renders those properties using VML for IE 6-8 and SVG for IE 9. Its rendering is mostly indistinguishable from native browser implementations and it handles dynamic DOM modification well.

JSON 2
Douglas Crockford originally wrote json2.js as an API for reading and writing his (then up-and-coming) JSON data format. It became so widely used that browser vendors decided to implement its API natively and turn it into a de facto standard; json2.js was transformed from a library to a polyfill after the fact.[clarification needed]

es5-shim
ECMAScript 5th Edition ("ES5") brings some useful new scripting features, and since they're syntactically compatible with older JavaScript engines they can mostly be polyfilled by patching methods onto built-in JS objects. This es5-shim polyfill does it in two parts: es5-shim.js contains those methods that can be fully polyfilled, and es5-sham.js contains partial implementations of the other methods which rely too much on the underlying engine to work accurately.

FlashCanvas
FlashCanvas is an implementation of the HTML5 Canvas API using a Flash plug-in. A rare commercial polyfill, it comes in a paid version, as well as a free version, which lacks a few advanced features like shadows.

MediaElement.js
John Dyer's MediaElement.js polyfills support for <video> and <audio> elements, including the HTML5 MediaElement API, in older browsers using Flash or Silverlight plug-ins. It also provides an optional media player UI for those elements, which is consistent across all browsers.

Webshims Lib
Alexander Farkas's Webshims Lib aggregates many other polyfills together into a single package and conditionally loads only those needed by the visiting browser.
===

Object Relational Mapping (ORM)
Object Relational Mapping (ORM, O/RM, and O/R Mapping) in computer science is a programming technique for converting data between incompatible type systems in object-oriented programming languages. This creates, in effect, a "virtual object database" that can be used from within the programming language. There are both free and commercial packages available that perform object-relational mapping, although some programmers opt to create their own ORM tools.

In object-oriented programming, data management tasks act on object-oriented (OO) objects that are almost always non-scalar values. For example, consider an address book entry that represents a single person along with zero or more phone numbers and zero or more addresses. This could be modeled in an object-oriented implementation by a "Person object" with attributes/fields to hold each data item that the entry comprises: the person's name, a list of phone numbers, and a list of addresses. The list of phone numbers would itself contain "PhoneNumber objects" and so on. The address book entry is treated as a single object by the programming language (it can be referenced by a single variable containing a pointer to the object, for instance). Various methods can be associated with the object, such as a method to return the preferred phone number, the home address, and so on.

However, many popular database products such as structured query language database management systems (SQL DBMS) can only store and manipulate scalar values such as integers and strings organized within tables. The programmer must either convert the object values into groups of simpler values for storage in the database (and convert them back upon retrieval), or only use simple scalar values within the program. Object-relational mapping is used to implement the first approach.[1]

The heart of the problem is translating the logical representation of the objects into an atomised form that is capable of being stored in the database, while preserving the properties of the objects and their relationships so that they can be reloaded as objects when needed. If this storage and retrieval functionality is implemented, the objects are said to be persistent.
===


