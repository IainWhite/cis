1,"<strong>Care About Your Craft</strong><br />Why spend your life developing software unless you care about doing it well?"
2,"<strong>Provide Options, Don't Make Lame Excuses</strong><br />Instead of excuses, provide options. Don't say it can't be done; explain what can be done."
3,"<strong>Be a Catalyst for Change</strong><br />You can't force change on people. Instead, show them how the future might be and help them participate in creating it."
4,"<strong>Make Quality a Requirements Issue</strong><br />Involve your users in determining the project's real quality requirements."
5,"<strong>Critically Analyze What You Read and Hear</strong><br />Don't be swayed by vendors, media hype, or dogma. Analyze information in terms of you and your project."
6,"<strong>DRY - Don't Repeat Yourself</strong><br />Every piece of knowledge must have a single, unambiguous, authoritative representation within a system."
7,"<strong>Eliminate Effects Between Unrelated Things</strong><br />Design components that are self-contained, independent, and have a single, well-defined purpose."
8,"<strong>Use Tracer Bullets to Find the Target</strong><br />Tracer bullets let you home in on your target by trying things and seeing how close they land."
9,"<strong>Program Close to the Problem Domain</strong><br />Design and code in your user's language."
10,"<strong>Iterate the Schedule with the Code</strong><br />Use experience you gain as you implement to refine the project time scales."
11,"<strong>Use the Power of Command Shells</strong><br />Use the shell when graphical user interfaces don't cut it."
12,"<strong>Always Use Source Code Control</strong><br />Source code control is a time machine for your work-you can go back."
13,"<strong>Don't Panic When Debugging</strong><br />Take a deep breath and <strong>THINK!</strong> about what could be causing the bug."
14,"<strong>Don't Assume It-Prove It</strong><br />Prove your assumptions in the actual environment-with real data and boundary conditions."
15,"<strong>Write Code That Writes Code</strong><br />Code generators increase your productivity and help avoid duplication."
16,"<strong>Design with Contracts</strong><br />Use contracts to document and verify that code does no more and no less than it claims to do."
17,"<strong>Use Assertions to Prevent the Impossible</strong><br />Assertions validate your assumptions. Use them to protect your code from an uncertain world."
18,"<strong>Finish What You Start</strong><br />Where possible, the routine or object that allocates a resource should be responsible for deallocating it."
19,"<strong>Configure, Don't Integrate</strong><br />Implement technology choices for an application as configuration options, not through integration or engineering."
20,"<strong>Analyze Workflow to Improve Concurrency</strong><br />Exploit concurrency in your user's workflow."
21,"<strong>Always Design for Concurrency</strong><br />Allow for concurrency, and you'll design cleaner interfaces with fewer assumptions."
22,"<strong>Use Blackboards to Coordinate Workflow</strong><br />Use blackboards to coordinate disparate facts and agents, while maintaining independence and isolation among participants."
23,"<strong>Estimate the Order of Your Algorithms</strong><br />Get a feel for how long things are likely to take before you write code."
24,"<strong>Refactor Early, Refactor Often</strong><br />Just as you might weed and rearrange a garden, rewrite, rework, and re-architect code when it needs it. Fix the root of the problem."
25,"<strong>Test Your Software, or Your Users Will</strong><br />Test ruthlessly. Don't make your users find bugs for you."
26,"<strong>Don't Gather Requirements-Dig for Them</strong><br />Requirements rarely lie on the surface. They're buried deep beneath layers of assumptions, misconceptions, and politics."
27,"<strong>Abstractions Live Longer than Details</strong><br />Invest in the abstraction, not the implementation. Abstractions can survive the barrage of changes from different implementations and new technologies."
28,"<strong>Don't Think Outside the Box-Find the Box</strong><br />When faced with an impossible problem, identify the real constraints. Ask yourself: 'Does it have to be done this way? Does it have to be done at all?'"
29,"<strong>Some Things Are Better Done than Described</strong><br />Don't fall into the specification spiral-at some point you need to start coding."
30,"<strong>Costly Tools Don't Produce Better Designs</strong><br />Beware of vendor hype, industry dogma, and the aura of the price tag. Judge tools on their merits."
31,"<strong>Don't Use Manual Procedures</strong><br />A shell script or batch file will execute the same instructions, in the same order, time after time."
32,"<strong>Coding Ain't Done 'Til All the Tests Run</strong><br />'Nuff said."
33,"<strong>Test State Coverage, Not Code Coverage</strong><br />Identify and test significant program states. Just testing lines of code isn't enough."
34,"<strong>English is Just a Programming Language</strong><br />Write documents as you would write code: honor the <strong>DRY</strong> principle, use metadata, MVC, automatic generation, and so on."
35,"<strong>Gently Exceed Your Users' Expectations</strong><br />Come to understand your users' expectations, then deliver just that little bit more."
36,"<strong>Think! About Your Work</strong><br />Turn off the autopilot and take control. Constantly critique and appraise your work."
37,"<strong>Don't Live with Broken Windows</strong><br />Fix bad designs, wrong decisions, and poor code when you see them."
38,"<strong>Remember the Big Picture</strong><br />Don't get so engrossed in the details that you forget to check what's happening around you."
39,"<strong>Invest Regularly in Your Knowledge Portfolio</strong><br />Make learning a habit."
40,"<strong>It's Both What You Say and the Way You Say It</strong><br />There's no point in having great ideas if you don't communicate them effectively."
41,"<strong>Make It Easy to Reuse</strong><br />If it's easy to reuse, people will. Create an environment that supports reuse."
42,"<strong>There Are No Final Decisions</strong><br />No decision is cast in stone. Instead, consider each as being written in the sand at the beach, and plan for change."
43,"<strong>Prototype to Learn</strong><br />Prototyping is a learning experience. Its value lies not in the code you produce, but in the lessons you learn."
44,"<strong>Estimate to Avoid Surprises</strong><br />Estimate before you start. You'll spot potential problems up front."
45,"<strong>Keep Knowledge in Plain Text</strong><br />Plain text won't become obsolete. It helps leverage your work and simplifies debugging and testing."
46,"<strong>Use a Single Editor Well</strong><br />The editor should be an extension of your hand; make sure your editor is configurable, extensible, and programmable."
47,"<strong>Fix the Problem, Not the Blame</strong><br />It doesn't really matter whether the bug is your fault or someone else's - it is still your problem, and it still needs to be fixed."
48,"<strong>'select' Isn't Broken</strong><br />It is rare to find a bug in the OS or the compiler, or even a third-party product or library. The bug is most likely in the application."
49,"<strong>Learn a Text Manipulation Language</strong><br />You spend a large part of each day working with text. Why not have the computer do some of it for you?"
50,"<strong>You Can't Write Perfect Software</strong><br />Software can't be perfect. Protect your code and users from the inevitable errors."
51,"<strong>Crash Early</strong><br />A dead program normally does a lot less damage than a crippled one."
52,"<strong>Use Exceptions for Exceptional Problems</strong><br />Exceptions can suffer from all the readability and maintainability problems of classic spaghetti code. Reserve exceptions for exceptional things."
53,"<strong>Minimize Coupling Between Modules</strong><br />Avoid coupling by writing 'shy' code and applying the Law of Demeter."
54,"<strong>Put Abstractions in Code, Details in Metadata</strong><br />Program for the general case, and put the specifics outside the compiled code base."
55,"<strong>Design Using Services</strong><br />Design in terms of services-independent, concurrent objects behind well-defined, consistent interfaces."
56,"<strong>Separate Views from Models</strong><br />Gain flexibility at low cost by designing your application in terms of models and views."
57,"<strong>Don't Program by Coincidence</strong><br />Rely only on reliable things. Beware of accidental complexity, and don't confuse a happy coincidence with a purposeful plan."
58,"<strong>Test Your Estimates</strong><br />Mathematical analysis of algorithms doesn't tell you everything. Try timing your code in its target environment."
59,"<strong>Design to Test</strong><br />Start thinking about testing before you write a line of code."
60,"<strong>Don't Use Wizard Code You Don't Understand</strong><br />Wizards can generate reams of code. Make sure you understand all of it before you incorporate it into your project."
61,"<strong>Work with a User to Think Like a User</strong><br />It's the best way to gain insight into how the system will really be used."
62,"<strong>Use a Project Glossary</strong><br />Create and maintain a single source of all the specific terms and vocabulary for a project."
63,"<strong>Start When You're Ready</strong><br />You've been building experience all your life. Don't ignore niggling doubts."
64,"<strong>Don't Be a Slave to Formal Methods</strong><br />Don't blindly adopt any technique without putting it into the context of your development practices and capabilities."
65,"<strong>Organize Teams Around Functionality</strong><br />Don't separate designers from coders, testers from data modelers. Build teams the way you build code."
66,"<strong>Test Early. Test Often. Test Automatically.</strong><br />Tests that run with every build are much more effective than test plans that sit on a shelf."
67,"<strong>Use Saboteurs to Test Your Testing</strong><br />Introduce bugs on purpose in a separate copy of the source to verify that testing will catch them."
68,"<strong>Find Bugs Once</strong><br />Once a human tester finds a bug, it should be the last time a human tester finds that bug. Automatic tests should check for it from then on."
69,"<strong>Build Documentation In, Don't Bolt It On</strong><br />Documentation created separately from code is less likely to be correct and up to date."
70,"<strong>Sign Your Work</strong><br />Craftsmen of an earlier age were proud to sign their work. You should be, too."